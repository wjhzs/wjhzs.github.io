{"meta":{"title":"魏经海个人博客","subtitle":"Welcome","description":"学习心得、资源分享、前端知识总结","author":"魏经海","url":"https://wjhzs.github.io","root":"/"},"pages":[{"title":"","date":"2020-07-24T22:52:47.943Z","updated":"2020-07-24T22:52:47.943Z","comments":true,"path":"404.html","permalink":"https://wjhzs.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2020-07-20T03:11:08.000Z","updated":"2020-07-20T03:18:46.593Z","comments":false,"path":"categories/index.html","permalink":"https://wjhzs.github.io/categories/index.html","excerpt":"","text":"分类"},{"title":"tags","date":"2020-07-20T03:10:59.000Z","updated":"2020-07-20T03:17:59.377Z","comments":false,"path":"tags/index.html","permalink":"https://wjhzs.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-20T04:39:37.000Z","updated":"2020-07-21T11:58:58.392Z","comments":true,"path":"custom/index.html","permalink":"https://wjhzs.github.io/custom/index.html","excerpt":"","text":"这是我觉得比较的实用的网站。感兴趣的话可以浏览看看 Jquery官网 https://jquery.com/ BootStrap官网 https://www.bootcss.com/ Vue官网 https://cn.vuejs.org/ React官网 https://reactjs.org/ 图床-免费图片上传 https://imgchr.com/ 图标库 http://www.fontawesome.com.cn/faicons/ 阿里巴巴矢量图标库 https://www.iconfont.cn/ CSS动画库 https://animate.style/ 在线生成透明ico图标 http://www.ico51.cn/ 28个纯css3 加载loading动画特效 http://demo.lanrenzhijia.com/2015/load0409/ 绿叶学习网 前端学习 http://www.lvyestudy.com/ 必应每日高清壁纸 https://bing.ioliu.cn/ 超好看的渐变色 适用前端页面css https://webgradients.com/ 音乐网站 全网音乐可听 http://tool.liumingye.cn/music/?page=homePage 视频网站 全网电影电视剧等资源 http://lab.liumingye.cn/ 链接更新中... 记得关注 资源分享贴 VSCode安装包 x64-1.39.2：百度网盘地址 提取码：c576 Photoshop CC2019 32位下载链接：百度网盘地址 提取码：s94t 64位下载链接：百度网盘地址 提取码：taqy 注册机下载链接：百度网盘地址 提取码：lkln 资源更新中...记得关注"}],"posts":[{"title":"git知识归纳","slug":"git知识归纳","date":"2020-11-15T13:50:42.000Z","updated":"2020-11-15T14:20:07.316Z","comments":true,"path":"2020/11/15/git知识归纳/","link":"","permalink":"https://wjhzs.github.io/2020/11/15/git%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/","excerpt":"git相关的名词解析git/svn 团队的代码管理工具 git是分布式 svn集中式git 里包含本地仓库 和远程仓库github/gitee 一大波远程仓库的集合体","text":"git相关的名词解析git/svn 团队的代码管理工具 git是分布式 svn集中式git 里包含本地仓库 和远程仓库github/gitee 一大波远程仓库的集合体 git远程仓库 团队使用在服务器的仓库git的本地仓库 本地创建随便使用gui 可视化工具 gitDesktop sourceTree conrestone vscode.git 隐藏文件 表示git的仓库工作区 可以可到的写代码的地方叫工作区暂存区 在git的仓库我们是看不到的用来暂时保存呢提交的修改分支 将用户的提交和修改按照时间形成一条链叫做分支版本合并版本冲突版本提交 基本指令1234567891011121314151617181920212223242526272829303132333435git status &#x2F;&#x2F; 查看当前仓库分支的一个基本状态git init &#x2F;&#x2F; 在本地初始化一个仓库git add &lt;file,dir&gt; &#x2F;&#x2F;将工作区的修改提交到暂存区 git commit -m &#39;注释&#39; &#x2F;&#x2F;将暂存区的修改提交到分支git log &#x2F;&#x2F; 打印提交记录git log --pretty&#x3D;oneline &#x2F;&#x2F;在一行内打印提交记录git reflog &#x2F;&#x2F;打印所有的git操作记录 git branch &#x2F;&#x2F;查看本地的所有分支git branch -a &#x2F;&#x2F;产看本地和远程的所有分支git checkout -b 分支名 &#x2F;&#x2F;创建并且切换一个分支git checkout 分支名 &#x2F;&#x2F;切换一个分支git merge 分支名(dev) &#x2F;&#x2F;在当前分支合并其他分支(dev) 子分支向母分支合并git reset --hard 提交id &#x2F;&#x2F;版本的滚动 只能是被git管理的git diff &#x2F;&#x2F;查看暂存区和工作区的区别git clone url &#x2F;&#x2F; 将远程的仓库克隆到本地git push origin（远程仓库名） master （分支名）git pull origin 分支名 （fecth + commit）拉取（下载）指定分支代码合并到当前分支git fetch 拉取代码git remote add origin url 将本地仓库和远程从仓库建立连接git branch -D 分支名删除本地分支 冲突需要的留着 不需要的删除 -&gt; 良好的交流 git仓库 本地仓库 远程仓库本地仓库和远程仓库都是仓库 该有的都有本地仓库 ：本地分支 （本地工作区 本地暂存区）远程仓库 ：远程分支 （远程工作区 远程暂存区） 远程仓库的创建 gitee github 自己在服务器上搭建远程仓库 已经存在一个远程仓库了 通过readme文件自动创建的 也可能是别人创建git clone + 地址 将远程仓库克隆到本地 没有远程仓库 本地通过git init 创建一个远程仓库 git remote add origin + 地址 和远程仓库做关联 git的分支gitflow git工作流git 的使用流程 更多是对分支的使用 master 主分支 线上分支 和正在线上运行的代码是一致的realease 分支 预发布分支 发布前的测试dev 分支 开发分支futrue 分支 个人分支 功能分支bug 分支 线上代码出现bug的时候来解决bug 角色主程 和远程仓库过关联 搭建项目框架 上传到远程的dev分支 开发结束之后 将dev分支的代码 合并到master （预上线分支）普通开发者 clone 代码 从dev分支切换出个人分支 在个人分支进行修改 将个人分支合并到dev分支 push dev分支 push 之前一定要先更新代码 将个人分支删除调重新创建","categories":[{"name":"git","slug":"git","permalink":"https://wjhzs.github.io/categories/git/"}],"tags":[],"author":"魏经海"},{"title":"imback","slug":"imback","date":"2020-11-15T13:31:56.000Z","updated":"2020-11-15T13:34:48.264Z","comments":true,"path":"2020/11/15/imback/","link":"","permalink":"https://wjhzs.github.io/2020/11/15/imback/","excerpt":"","text":"时隔两个月，我挂载到GitHub上的hexo博客网站又能进去了….","categories":[],"tags":[],"author":"魏经海"},{"title":"开学","slug":"开学","date":"2020-09-06T07:01:33.000Z","updated":"2020-09-06T07:05:36.731Z","comments":true,"path":"2020/09/06/开学/","link":"","permalink":"https://wjhzs.github.io/2020/09/06/%E5%BC%80%E5%AD%A6/","excerpt":"","text":"开学第一天…… 头几天肯定一大堆大大小小的琐事 忙完这几天继续加油","categories":[],"tags":[],"author":"魏经海"},{"title":"git分支操作","slug":"git分支操作","date":"2020-08-15T02:17:29.000Z","updated":"2020-08-15T02:31:07.357Z","comments":true,"path":"2020/08/15/git分支操作/","link":"","permalink":"https://wjhzs.github.io/2020/08/15/git%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/","excerpt":"分支 将用户的提交和修改按照时间形成一条链叫做分支 总结git基本指令 git status 查看当前仓库分支的一个基本状态 git init 在本地初始化一个仓库","text":"分支 将用户的提交和修改按照时间形成一条链叫做分支 总结git基本指令 git status 查看当前仓库分支的一个基本状态 git init 在本地初始化一个仓库 git add &lt;file,dir&gt; 将工作区的修改提交到暂存区 git commit -m &#39;注释&#39; 将暂存区的修改提交到分支 git log 打印提交记录 git log --pretty=oneline 在一行内打印提交记录 git reflog 打印所有的git操作记录 git branch 查看本地的所有分支 git branch -a 产看本地和远程的所有分支 git checkout -b 分支名 创建并且切换一个分支 git checkout 分支名 切换一个分支 git merge 分支名(dev) 在当前分支合并其他分支(dev) 子分支向母分支合并 git reset --hard 提交id 版本的滚动 只能是被git管理的 git diff 查看暂存区和工作区的区别 git clone url 将远程的仓库克隆到本地git push origin（远程仓库名） master （分支名） 上传远程仓库git pull origin 分支名 （fecth + commit）拉取（下载）指定分支代码合并到当前分支git fetch 拉取代码git remote add origin 仓库地址 将本地仓库和远程从仓库建立连接 git branch -D 分支名 删除本地分支 git的分支####gitflow git工作流 git 的使用流程 更多是对分支的使用 master 主分支 线上分支 和正在线上运行的代码是一致的realease 分支 预发布分支 发布前的测试dev 分支 开发分支future 分支 个人分支 功能分支bug 分支 线上代码出现bug的时候来解决bug 角色主程 1.和远程仓库过关联 2.搭建项目框架 3.上传到远程的dev分支 4.开发结束之后 将dev分支的代码 合并到master （预上线分支） 普通开发者 1.clone 代码 2.从dev分支切换出个人分支 3.在个人分支进行修改 4.将个人分支合并到dev分支 5.push dev分支 push 之前一定要先更新代码 6.将个人分支删除调重新创建","categories":[{"name":"git","slug":"git","permalink":"https://wjhzs.github.io/categories/git/"}],"tags":[{"name":"git分支","slug":"git分支","permalink":"https://wjhzs.github.io/tags/git%E5%88%86%E6%94%AF/"}],"author":"魏经海"},{"title":"Vue全局状态管理","slug":"Vue全局状态管理","date":"2020-08-10T01:04:40.000Z","updated":"2020-08-10T01:32:21.381Z","comments":true,"path":"2020/08/10/Vue全局状态管理/","link":"","permalink":"https://wjhzs.github.io/2020/08/10/Vue%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","excerpt":"全局状态管理 1.多组件共享状态 多个组件使用同一个数据2.任何一个组件发生改变 其他的组件也要跟着发生相应的变化","text":"全局状态管理 1.多组件共享状态 多个组件使用同一个数据2.任何一个组件发生改变 其他的组件也要跟着发生相应的变化 基本使用0.下载 npm install vuex1.创建全局状态管理的实例2.注册3.在组件里使用全局状态值 a.获取渲染全局状态值 b.修改全局状态值 5大核心state 全局状态数据mutation 规定只有mutation才能修改state 通过commit方法触发action 可以放异步操作 触发mutation 通过dispatch 触发getter vuex里的计算属性 和state值进行关联 state发生改变，可以重新计算，并且可以在页面上直接使用 action 存放异步1.统一管理异步请求减少代码量2.时间旅行更加准确 vue的开发者工具 最简版1.组件里通过 $store.state 获取全局状态数据进行渲染2.通过 $store.commit 方法触发mutation 修改全局状态值 整个页面都会变 模块化1.模块化之后state的取值需要添加一级模块名 其他的三个核心不变2.可以在模块里添加命名空间 作用就是在 mutation getters actions的名字前面 添加模块名用处就是防止名字冲突 稍微复杂版1.组件里通过 $store.state 获取全局状态数据进行渲染2.通过 $store.dispath方法 触发action里的方法3.action 触发mutation进行修改全局状态值 辅助函数帮助我们减少代码量 值类型向计算属性映射mapState 将全局状态管理的state值映射到使用组价的计算属性mapGetters 将全局状态管理的getters值映射到使用组价的计算属性 函数类型向methods进行映射mapMutatio\bns 将mutation的值映射到 方法里mapActions 将actions里的值映射到方法 vue开发者工具 vue.js devtools在谷歌浏览器网上应用商店下载… 可以先下载谷歌访问助手再进应用商店 开发者工具绿了 该网页一定是vue做的vue做的网页开发者工具不一定绿","categories":[{"name":"Vue","slug":"Vue","permalink":"https://wjhzs.github.io/categories/Vue/"}],"tags":[{"name":"Vue全局状态管理模式","slug":"Vue全局状态管理模式","permalink":"https://wjhzs.github.io/tags/Vue%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F/"}],"author":"魏经海"},{"title":"Mongobd","slug":"Mongobd","date":"2020-07-23T02:48:30.000Z","updated":"2020-07-23T02:51:08.563Z","comments":true,"path":"2020/07/23/Mongobd/","link":"","permalink":"https://wjhzs.github.io/2020/07/23/Mongobd/","excerpt":"","text":"非关系型数据库-mongodb","categories":[{"name":"Mongodb","slug":"Mongodb","permalink":"https://wjhzs.github.io/categories/Mongodb/"}],"tags":[{"name":"mongodb介绍","slug":"mongodb介绍","permalink":"https://wjhzs.github.io/tags/mongodb%E4%BB%8B%E7%BB%8D/"}],"author":"魏经海"},{"title":"MySQL","slug":"MySQL","date":"2020-07-23T02:47:55.000Z","updated":"2020-07-23T03:25:37.277Z","comments":true,"path":"2020/07/23/MySQL/","link":"","permalink":"https://wjhzs.github.io/2020/07/23/MySQL/","excerpt":"","text":"关系型数据库-MySQL","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://wjhzs.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL介绍","slug":"MySQL介绍","permalink":"https://wjhzs.github.io/tags/MySQL%E4%BB%8B%E7%BB%8D/"}],"author":"魏经海"},{"title":"JavaScript","slug":"JavaScript","date":"2020-07-23T02:47:34.000Z","updated":"2020-07-23T02:49:54.757Z","comments":true,"path":"2020/07/23/JavaScript/","link":"","permalink":"https://wjhzs.github.io/2020/07/23/JavaScript/","excerpt":"","text":"","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wjhzs.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript介绍","slug":"JavaScript介绍","permalink":"https://wjhzs.github.io/tags/JavaScript%E4%BB%8B%E7%BB%8D/"}],"author":"魏经海"},{"title":"CSS","slug":"CSS","date":"2020-07-23T02:47:25.000Z","updated":"2020-07-23T03:19:40.364Z","comments":true,"path":"2020/07/23/CSS/","link":"","permalink":"https://wjhzs.github.io/2020/07/23/CSS/","excerpt":"","text":"","categories":[{"name":"CSS","slug":"CSS","permalink":"https://wjhzs.github.io/categories/CSS/"}],"tags":[{"name":"CSS介绍","slug":"CSS介绍","permalink":"https://wjhzs.github.io/tags/CSS%E4%BB%8B%E7%BB%8D/"}],"author":"魏经海"},{"title":"HTML","slug":"HTML","date":"2020-07-23T02:47:19.000Z","updated":"2020-07-23T02:49:16.958Z","comments":true,"path":"2020/07/23/HTML/","link":"","permalink":"https://wjhzs.github.io/2020/07/23/HTML/","excerpt":"","text":"","categories":[{"name":"HTML","slug":"HTML","permalink":"https://wjhzs.github.io/categories/HTML/"}],"tags":[{"name":"HTML介绍","slug":"HTML介绍","permalink":"https://wjhzs.github.io/tags/HTML%E4%BB%8B%E7%BB%8D/"}],"author":"魏经海"},{"title":"git操作","slug":"git操作","date":"2020-07-23T02:45:39.000Z","updated":"2020-08-14T11:20:39.003Z","comments":true,"path":"2020/07/23/git操作/","link":"","permalink":"https://wjhzs.github.io/2020/07/23/git%E6%93%8D%E4%BD%9C/","excerpt":"git介绍git是一款本地项目管理工具，git在使用时必须严格遵守项目git规范，否则会影响整个项目的进度和文件的整理保存。 git官网：https://github.com/ 全英文 gittee官网：https://gitee.com/ 中文版git","text":"git介绍git是一款本地项目管理工具，git在使用时必须严格遵守项目git规范，否则会影响整个项目的进度和文件的整理保存。 git官网：https://github.com/ 全英文 gittee官网：https://gitee.com/ 中文版git git的安装通过官网下载，一直点击下一步就ok！ 在任意一个文件目录下点击鼠标右键，出现Git GUI Here 和 Git Bash Here 就说明安装成功 首次使用git，要在命令行中进行以下操作： 1.git config --list 检查git全局配置 执行之后，显示的是git默认的系统配置 2.设定用户名称 git config --global usename &quot;你的用户名&quot;；用户名必须为英文，可以使用GitHub的用户名 设定用户邮箱 git config --global user.email &quot;你的电子邮箱&quot;；邮箱设定为常用的邮箱，可以正确手法邮件的邮箱 git的工作原理操作git必须严格按照以下操作步骤来进行操作 1.设定一个需要git软件来管理的项目文件夹 2.在这个目录下，鼠标右击，使用git bush here 运行程序，也可以直接在命令行操作，记得切换路径 3.运行git init 格式化当前文件夹，运行之后，会得到一个.git文件，这个文件默认是隐藏的，可以通过文件设置让它显示，这个文件十分重要，不能删除 项目问文件夹分为工作区 缓存区 历史区 工作区：平时我们编辑的执行的文件，都在工作区中，是可见的，可以编辑操作 缓存区：从工作区上传存储到缓存区，是不可见的，无法编辑操作，缓存区的内容可以回滚到工作区 历史区：从缓存区上传存储到历史区是不可见的，历史区的文件生成历史版本，可以上传到GitHub上，历史区的内容可以回滚到工作区，GitHub中的内容可以下载到工作区继续编辑 4.具体的执行命令 git status：查看缓存区中的文件 git add 文件名：上传一个文件到缓存区 git add 文件夹名：上传一个文件夹到缓存区 git add .(英文的点)/git add --all 添加项目文件夹中的所有内容到缓存区 git commit -m &quot;注释内容&quot;：将缓存区中的所有内容上传到历史区，生成历史版本 git log：查看历史版本 生成历史版本之后，当前缓存区中的所有内容会被全部释放，也就是缓存区中没有任何内容了 回滚操作1.从缓存区回滚到工作区 git reset HEAD --文件名：文件回滚 git reset HEAD --文件夹名：文件夹回滚 git reset HEAD -- .：所有文件回滚 2.切换当前使用的历史版本 git reset --hard 历史版本id （commit之后的英文串就是id） 3.历史版本一旦生成是无法删除的，新的历史版本是在之前历史版本的基础上生成的内容，如果删除了之前的历史版本，之后的内容也会受到影响，因此git的历史版本不允许删除！ 使用GitHub进行云存储git项目文件在GitHub中新建库，通过本地git将历史版本存入GitHub仓库 1.上传历史版本之前先要配置git上传信息 通过git remote add origin 仓库地址设置项目文件存储在哪个库，在git文件夹config文件中，会显示设置的这个仓库地址，如果地址需要更换，可在文件里面直接修改，或者重新输入上面那行命令 2.上传操作命令 git push -u origin master 3.下载克隆操作 git clone 仓库地址 git项目的分支操作待更新中…….","categories":[{"name":"git","slug":"git","permalink":"https://wjhzs.github.io/categories/git/"}],"tags":[{"name":"git介绍","slug":"git介绍","permalink":"https://wjhzs.github.io/tags/git%E4%BB%8B%E7%BB%8D/"}],"author":"魏经海"},{"title":"Node.js","slug":"Node-js","date":"2020-07-23T02:44:28.000Z","updated":"2020-11-15T13:44:11.156Z","comments":true,"path":"2020/07/23/Node-js/","link":"","permalink":"https://wjhzs.github.io/2020/07/23/Node-js/","excerpt":"","text":"Node课程笔记 Node 简介客户端的JavaScript是怎样的 什么是 JavaScript？+是一个脚本语言+运行在浏览器（浏览器的js解析内核 v8）+实现用户的交互 （interactive） 变量 赋值 循环 逻辑 判断 分支 对象 函数。。。。 dom 操作 bom 操作 ajax JavaScript 的运行环境？+浏览器内核解析内核 es6 浏览器中的 JavaScript 可以做什么？ 浏览器中的 JavaScript 不可以做什么？（不安全）+访问数据库+不能对文件进行操作+对os 进行操作+原因 是不安全 和浏览器运行机制有关 在开发人员能力相同的情况下编程语言的能力取决于什么？ +cordova hbuilder 平台 platform+java java虚拟机 （运行平台）+php php虚拟机+c# .net framework mono+js 解析内核 chrome v8 JavaScript 只可以运行在浏览器中吗？+不是 为什么是JavaScript node js 不是因为js 产生的 node 选择了js Ryan dahl 2009 2 月份 node有想法 2009 5 月份 githup 开源 2009 11月份 jsconf 讲解推广node 2010年底 被xxx公司收购 2018 发布有重大bug npm githup 世界上最大的同性交友网站 码云 what is node ？ Node.js 是一个基于Chrome V8 引擎的JavaScript运行环境 Node.js使用了一个事件驱动、非阻塞式I/O的模型,使其轻量又高效 Node.js的包管理工具npm,是全球最大的开源库生态系统 官网 http://nodejs.cn/ npm 插件官网：https://www.npmjs.com/ 环境配置Node的安装 安装包安装 官网下载对应的安装包 一路next nvm安装(有一个类似的工具：n) Node Version Manager（Node版本管理工具） 由于以后的开发工作可能会在多个Node版本中测试，而且Node的版本也比较多，所以需要这么款工具来管理 下载地址 12345基本命令nvm -v 查看版本号nvm list 查看列表nvm install 版本号 安装nodenvm uninstall 版本号 卸载node 相关版本 node版本常识 偶数版本为稳定版 （0.6.x ，0.8.x ，0.10.x） 奇数版本为非稳定版（0.7.x ，0.9.x ，0.11.x） LTS（Long Term Support） LTS和Current区别 操作方式： 重新下载最新的安装包； 覆盖安装即可； 问题： 以前版本安装的很多全局的工具包需要重新安装 无法回滚到之前的版本 无法在多个版本之间切换（很多时候我们要使用特定版本） Windows下常用的命令行操作 切换当前目录（change directory）：cd 创建目录（make directory）：mkdir 查看当前目录列表（directory）：dir 别名：ls（list） 清空当前控制台：cls 别名：clear 删除文件：del 别名：rm 注意：所有别名必须在新版本的 PowerShell （linux系统）中使用 常见问题 Python环境丢失 Node中有些第三方的包是以C/C++源码的方式发布的，需要安装后编译,确保全局环境中可以使用python命令,python 版本推荐2.7.0 环境变量丢失 部分电脑安装完毕之后没有环境变量需要手动配置 Windows中环境变量分为系统变量和用户变量 环境变量的变量名是不区分大小写的 PATH 变量：只要添加到 PATH 变量中的路径，都可以在任何目录下 目的可以在任何地方调起node命令 模块,包 commonjscommonjs规范前端模块化：AMD,CMD,Commonjs Node 应用由模块组成，采用 CommonJS 模块规范。 定义module每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 暴露接口 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 123456 var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 引用 require方法用于加载模块。 123 var example &#x3D; require(&#39;.&#x2F;example.js&#39;);console.log(example.x); &#x2F;&#x2F; 5console.log(example.addX(1)); &#x2F;&#x2F; 6 模块的分类 内置模块 1234const process &#x3D; require(&#39;process&#39;)const path &#x3D; require(&#39;path&#39;)console.log(process.version)console.log(path.resolve(&#39;..&#x2F;&#39;)) 第三方模块 12345678910 const request&#x3D;require(&quot;request&quot;);console.log(request)request.get(&#39;http:&#x2F;&#x2F;api.douban.com&#x2F;v2&#x2F;movie&#x2F;in_theaters&#39;, (err, response, body) &#x3D;&gt; &#123; if (!err) &#123; &#x2F;&#x2F; console.log(body); console.log(JSON.parse(body)) &#125; else &#123; console.log(err); &#125;&#125;) 自定义模块 npm 使用入门 官网:https://www.npmjs.com/ 安装：无需安装 查看当前版本： 1$ npm -v 更新： 1$ npm install npm@latest -g 初始化工程 123$ npm init$ npm init --yes 默认配置 安装包 使用npm install会读取package.json文件来安装模块。安装的模块分为两类 dependencies和devDependencies，分别对应生产环境需要的安装包和开发环境需要的安装包。 1234567$ npm install$ npm install &lt;package_name&gt; $ npm install &lt;package_name&gt; --save$ npm install &lt;package_name&gt; --save-dev 更新模块 1$ npm update 卸载模块 123$ npm uninstall &lt;package_name&gt;$ npm uninstall --save lodash 配置npm源 临时使用, 安装包的时候通过–registry参数即可 $ npm install express –registry https://registry.npm.taobao.org 全局使用 12345$ npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;&#x2F; 配置后可通过下面方式来验证是否成功npm config get registry&#x2F;&#x2F; 或npm info express cnpm 使用 12345&#x2F;&#x2F; 安装cnpm npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org &#x2F;&#x2F; 使用cnpm安装包 cnpm install express 常用的内置模块node 常用内置api (1) URL 网址解析 解析URL相关网址信息 url.parse(urlString[, parseQueryString[, slashesDenoteHost]]) url.format(urlObject) url.resolve(from, to)(2) QueryString 参数处理 querystring.escape(str) querystring.unescape(str) querystring.parse(str[, sep[, eq[, options]]]) querystring.stringify(obj[, sep[, eq[, options]]])(3) HTTP 模块概要 http.createServer([options][, requestListener]) http.get(options[, callback]) 简易的爬虫 代理跨域处理(4) 事件 events 模块(5) 文件fs模块 打印目录树(6) Stream 流模块 歌词播放 音乐下载(8) request 方法 2、Node.js 基础应用1、应用 HTTP 模块编写一个小爬虫工具(1) 利用爬虫获取“拉勾网”首页列表数据(2) 通过 npm 安装 cheerio 模块获得数据2、后端表单的提交要求:(1) 应用 request post 模拟提交表单 文件读取Node中文件读取的方式主要有： fs.readFile(file[, options], callback(error, data)) 1234fs.readFile('c:\\\\demo\\1.txt', 'utf8', (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;); fs.readFileSync(file[, options]) 1234567try &#123; const data = fs.readFileSync('c:\\\\demo\\1.txt', 'utf8'); console.log(data);&#125; catch(e) &#123; // 文件不存在，或者权限错误 throw e;&#125; fs.createReadStream(path[, options]) 12345678const stream = fs.createReadStream('c:\\\\demo\\1.txt');let data = ''stream.on('data', (trunk) =&gt; &#123; data += trunk;&#125;);stream.on('end', () =&gt; &#123; console.log(data);&#125;); 由于Windows平台下默认文件编码是GBK，在Node中不支持，可以通过iconv-lite解决 Readline模块逐行读取文本内容12345678910const readline = require('readline');const fs = require('fs');const rl = readline.createInterface(&#123; input: fs.createReadStream('sample.txt')&#125;);rl.on('line', (line) =&gt; &#123; console.log('Line from file:', line);&#125;); 文件写入Node中文件写入的方式主要有： fs.writeFile(file, data[, options], callback(error)) 123fs.writeFile('c:\\\\demo\\a.txt', new Date(), (error) =&gt; &#123; console.log(error);&#125;); fs.writeFileSync(file, data[, options]) 123456try &#123; fs.writeFileSync('c:\\\\demo\\a.txt', new Date());&#125; catch (error) &#123; // 文件夹不存在，或者权限错误 console.log(error);&#125; fs.createWriteStream(path[,option]) 123456var streamWriter = fs.createWriteStream('c:\\\\demo\\a.txt');setInterval(() =&gt; &#123; streamWriter.write(`$&#123;new Date&#125;\\n`, (error) =&gt; &#123; console.log(error); &#125;);&#125;, 1000); node中的异步操作 fs模块对文件的几乎所有操作都有同步和异步两种形式 例如：readFile() 和 readFileSync() 区别： 同步调用会阻塞代码的执行，异步则不会 异步调用会将读取任务下达到任务队列，直到任务执行完成才会回调 异常处理方面，同步必须使用 try catch 方式，异步可以通过回调函数的第一个参数 123456789101112131415console.time('sync');try &#123; var data = fs.readFileSync(path.join('C:\\\\Users\\\\iceStone\\\\Downloads', 'H.mp4')); // console.log(data);&#125; catch (error) &#123; throw error;&#125;console.timeEnd('sync');console.time('async');fs.readFile(path.join('C:\\\\Users\\\\iceStone\\\\Downloads', 'H.mp4'), (error, data) =&gt; &#123; if (error) throw error; // console.log(data);&#125;);console.timeEnd('async'); promise 对象的使用参考资料：JavaScript Promise迷你书 what is Promise *Promise是抽象异步处理对象以及对其进行各种操作的组件。Promise并不是从JavaScript中发祥的概念。Promise最初被提出是在 E语言中， 它是基于并列/并行处理设计的一种编程语言。现在JavaScript也拥有了这种特性，这就是JavaScript Promise 使用了回调函数的异步处理 123456789----getAsync(\"fileA.txt\", function(error, result)&#123; if(error)&#123;// 取得失败时的处理 throw error; &#125; // 取得成功时的处理&#125;);----&lt;1&gt; 传给回调函数的参数为(error对象， 执行结果)错误优先处理 使用了回调函数的异步处理 123456789----var promise = getAsyncPromise(\"fileA.txt\"); promise.then(function(result)&#123; // 获取文件内容成功时的处理&#125;).catch(function(error)&#123; // 获取文件内容失败时的处理&#125;);----&lt;1&gt; 返回promise对象 创建Promise对象 * 123456var promise &#x3D; new Promise(function(resolve, reject) &#123; &#x2F;&#x2F; 异步处理 &#x2F;&#x2F; 处理结束后、调用resolve 或 reject resolve(&#39;成功处理&#39;) reject(&#39;错误处理&#39;)&#125;); 使用实例 * 创建一个priomise 对象并返回new Promise(fn) 在fn 中指定异步等处理 处理结果正常的话，调用resolve(处理结果值) 处理结果错误的话，调用 reject(Error对象) 1234567891011121314function asyncFunction() &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve('Async Hello world'); &#125;, 16); &#125;);&#125;asyncFunction().then(function (value) &#123; console.log(value); // =&gt; 'Async Hello world'&#125;).catch(function (error) &#123; console.log(error);&#125;); Promise的状态 用new Promise 实例化的promise对象有以下三个状态。 “has-resolution” - Fulfilled resolve(成功)时。 “has-rejection” - Rejected reject(失败)时 “unresolved” - Pending 既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等 promise对象的状态，从Pending转换为Fulfilled或Rejected之后， 这个promise对象的状态就不会再发生任何变化。 也就是说，Promise与Event等不同，在.then 后执行的函数可以肯定地说只会被调用一次。 另外，Fulfilled和Rejected这两个中的任一状态都可以表示为Settled(不变的)。 Settledresolve(成功) 或 reject(失败)。 从Pending和Settled的对称关系来看，Promise状态的种类/迁移是非常简单易懂的。 当promise的对象状态发生变化时，用.then 来定义只会被调用一次的函数。 路径模块在文件操作的过程中，都必须使用物理路径（绝对路径），path模块提供了一系列与路径相关的 API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879console.log('join用于拼接多个路径部分，并转化为正常格式');const temp = path.join(__dirname, '..', 'lyrics', './友谊之光.lrc');console.log(temp);console.log('获取路径中的文件名');console.log(path.basename(temp));console.log('获取路径中的文件名并排除扩展名');console.log(path.basename(temp, '.lrc'));console.log('====================================');console.log('获取不同操作系统的路径分隔符');console.log(process.platform + '的分隔符为 ' + path.delimiter);console.log('一般用于分割环境变量');console.log(process.env.PATH.split(path.delimiter));console.log('====================================');console.log('获取一个路径中的目录部分');console.log(path.dirname(temp));console.log('====================================');console.log('获取一个路径中最后的扩展名');console.log(path.extname(temp));console.log('====================================');console.log('将一个路径解析成一个对象的形式');const pathObject = path.parse(temp);console.log(pathObject);console.log('====================================');console.log('将一个路径对象再转换为一个字符串的形式');// pathObject.name = '我终于失去了你';pathObject.base = '我终于失去了你.lrc';console.log(pathObject);console.log(path.format(pathObject));console.log('====================================');console.log('获取一个路径是不是绝对路径');console.log(path.isAbsolute(temp));console.log(path.isAbsolute('../lyrics/爱的代价.lrc'));console.log('====================================');console.log('将一个路径转换为当前系统默认的标准格式，并解析其中的./和../');console.log(path.normalize('c:/develop/demo\\\\hello/../world/./a.txt'));console.log('====================================');console.log('获取第二个路径相对第一个路径的相对路径');console.log(path.relative(__dirname, temp));console.log('====================================');console.log('以类似命令行cd命令的方式拼接路径');console.log(path.resolve(temp, 'c:/', './develop', '../application'));console.log('====================================');console.log('获取不同平台中路径的分隔符（默认）');console.log(path.sep);console.log('====================================');console.log('允许在任意平台下以WIN32的方法调用PATH对象');// console.log(path.win32);console.log(path === path.win32);console.log('====================================');console.log('允许在任意平台下以POSIX的方法调用PATH对象');console.log(path === path.posix); express 官网:http://www.expressjs.com.cn/ express 环境搭建安装 1$ npm install express --save 快速开始 1234const express = require('express') const app = express() app.get('/', (req, res) =&gt; res.send('Hello World!')) app.listen(3000, () =&gt; console.log('Example app listening on port 3000!')) express 路由配置12345678910111213141516171819let express=require('express')let router=express.Router()// 该路由使用的中间件router.use((req,res,next)=&gt;&#123; next()&#125;);// 定义网站主页的路由router.post('/addFood', function(req, res) &#123; console.log('hahaha') // res.send('这里是admin的登录');&#125;);// 定义 about 页面的路由router.post('/regist', function(req, res) &#123; res.send('这里是admin的注册侧');&#125;);module.exports = router;app.use('/admin',admin) 传递数据的获取12345678getreq.querypostreq.bodybody-parser设置中文格式res.set(&#39;Content-Type&#39;,&#39;text&#x2F;plain,charset&#x3D;utf8&#39;) 请求模拟工具 postman静态资源配置12345app.use(express.static('public'))app.use('/static', express.static('public'))app.use('/static', express.static(path.join(__dirname, 'public'))) mongod安装配置 在Mongodb官网下载最新版本的Mongodb下载地址 下载msi的window安装包，可以装到C盘或者D盘目录下 配置由于我是安装在D盘的环境下 1D:\\Program Files (x86)\\MongoDB\\Server\\3.2\\bin 所以在bin文件夹下找到mongod.exe命令，然后通过管理员执行mongod --dbpath x路径x，路径可以是任何地方，我这里选择在D盘的MongoDB目录下，当然路径不要包含特殊的字符串，比如Program Files (x86)也不行 1mongod --dbpath D:\\mongodb\\data\\db image 命令行经过上面的配置之后，就可以返回bin目录下找到mongo.exe命令，并管理员下执行，就可以出现mongodb的命令行模式 1D:\\Program Files (x86)\\MongoDB\\Server\\3.2\\bin image 然后就可以使用下面的命令来测试了 mongod 12db.help()//帮助db.stats()//统计 显示数据库1show dbs 检查当前选择的数据库 1db 添加数据库数据库名为数据库创建的名字，使用该命令后会默认切换到对应的数据库，并且在数据库中添加选项，数据库信息才显示，如果默认就有该数据库，那就是切换到对应的数据库里面 1use 数据库名 删除数据库先切换到对应的数据库，然后再执行db.dropDatabase()删除该数据库 123use 数据库名//switched to db 数据库名db.dropDatabase() 显示集合用一下命令可以检查创建的集合 1show collections 添加集合在创建完数据库之后，我们就可以创建集合 1db.createCollection(集合名字name，设置参数options[对象类型]) name是要创建的集合的名称。 options是一个文档，用于指定集合的配置 参数 类型 描述name String 要创建的集合的名称options Document (可选)指定有关内存大小和索引的选项options参数是可选的，因此只需要指定集合的名称。 以下是可以使用的选项列表： 字段 类型 描述capped Boolean (可选)如果为true，则启用封闭的集合。上限集合是固定大小的集合，它在达到其最大大小时自动覆盖其最旧的条目。 如果指定true，则还需要指定size参数。autoIndexId Boolean (可选)如果为true，则在_id字段上自动创建索引。默认值为false。size 数字 (可选)指定上限集合的最大大小(以字节为单位)。 如果capped为true，那么还需要指定此字段的值。max 数字 (可选)指定上限集合中允许的最大文档数。由于option是可选，我们也可以不带配置项创建集合 1db.createCollection(\"mycollection\") 删除集合db.collection.drop()用于从数据库中删除集合 1db.集合名.drop() 比如我们可以测试以下操作 123db.createCollection(\"wscats\")//创建名为wscats的集合show collections//显示该数据库所有集合 wscatsdb.wscats.drop()//删除名为wscats的集合 查看文档最简单查看文档的方法就是find()，会检索集合中所有的文档结果 1db.集合名.find() 要以格式化的方式显示结果，可以使用pretty()方法。 1db.集合名.find().pretty() 1.固值寻找寻找age集合里面所有含有属性值为wscats的文档结果，相当于where name = &#39;wscats&#39; 1db.age.find(&#123;name:\"wscats\"&#125;) 2.范值寻找操作 语法 示例 等效语句相等 {:} db.age.find({&quot;name&quot;:&quot;wscats&quot;}).pretty() where name = ‘wscats’小于 {:{$lt:}} db.age.find({&quot;likes&quot;:{$lt:50}}).pretty() where likes &lt; 50小于等于 {:{$lte:}} db.age.find({&quot;likes&quot;:{$lte:50}}).pretty() where likes &lt;= 50大于 {:{$gt:}} db.age.find({&quot;likes&quot;:{$gt:50}}).pretty() where likes &gt; 50大于等于 {:{$gte:}} db.age.find({&quot;likes&quot;:{$gte:50}}).pretty() where likes &gt;= 50不等于 {:{$ne:}} db.age.find({&quot;likes&quot;:{$ne:50}}).pretty() where likes != 50 3.AND和OR寻找AND在find()方法中，如果通过使用，将它们分开传递多个键，则mongodb将其视为AND条件。 以下是AND的基本语法 寻找_id为1并且name为wscats的所有结果集 1234567db.age.find( &#123; $and: [ &#123;\"_id\": 1&#125;, &#123;\"name\": \"wscats\"&#125; ] &#125;) OR在要根据OR条件查询文档，需要使用$or关键字。以下是OR条件的基本语法 寻找name为corrine或者name为wscats的所有结果集 1234567db.age.find( &#123; $or: [ &#123;\"name\": \"corrine\"&#125;, &#123;“name“: \"wscats\"&#125; ] &#125;) AND和OR等结合相当于语句where title = &quot;wscats&quot; OR ( title = &quot;corrine&quot; AND _id &lt; 5) 12345678910111213db.age.find(&#123; $or: [&#123; \"title\": \"wscats\" &#125;, &#123; $and: [&#123; \"title\": \"corrine\" &#125;, &#123; \"_id\": &#123; $lte: 5 &#125; &#125;] &#125;]&#125;) 插入文档文档的数据结构和JSON基本一样。所有存储在集合中的数据都是BSON格式。BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。 要将数据插入到mongodb集合中，需要使用mongodb的insert()或save()方法。 1db.集合名.insert(document) 比如我们可以插入以下数据 123456789db.wscats.insert(&#123; _id: 100, title: 'MongoDB Tutorials', description: 'node_tutorials', by: 'Oaoafly', url: 'https://github.com/Wscats/node-tutorial', tags: ['wscat','MongoDB', 'database', 'NoSQL','node'], num: 100,&#125;) 也可以支持插入多个，注意传入的是数组形式 1234567db.wscats.insert([&#123; _id: 100, title: ‘Hello’&#125;,&#123; _id: 101, title: ‘World’&#125;]) 在插入的文档中，如果不指定_id参数，那么mongodb会为此文档分配一个唯一的ObjectId要插入文档，也可以使用db.post.save(document)。如果不在文档中指定_id，那么save()方法将与insert()方法一样自动分配ID的值。如果指定_id，则将以save()方法的形式替换包含_id的文档的全部数据。 1234db.wscats.save(&#123; _id: 111, title: 'Oaoafly Wscats', &#125;) 更新文档1.update()方法寻找第一条title为wscats的值，并且更新值title为corrine和age为12 12345678db.age.update(&#123; 'title': 'wscats'&#125;, &#123; $set: &#123; 'title': 'corrine', 'age': 12 &#125;&#125;) 默认情况下，mongodb只会更新一个文档。要更新多个文档，需要将参数multi设置为true，还可以配合find方法里面的各种复杂条件判断来筛选结果，然后更新多个文档 寻找所有title为wscats的值，并且更新值title为corrine和age为12 12345678910db.age.update(&#123; 'title': 'wscats'&#125;, &#123; $set: &#123; 'title': 'corrine', 'age': 12 &#125;&#125;, &#123; multi: true&#125;) 2.save()方法将_id主键为3的文档，覆盖新的值，注意_id为必传 12345db.age.save(&#123; &#39;_id&#39;:3, &#39;title&#39;: &#39;wscats&#39;&#125;) 删除文档删除主键_id为3的文档，默认是删除多条 123db.age.remove(&#123; '_id':3&#125;) 建议在执行remove()函数前先执行find()命令来判断执行的条件是否正确 如果你只想删除第一条找到的记录可以设置justOne为1，如下所示 1db.age.remove(&#123;...&#125;,1) 全部删除 1db.age.remove(&#123;&#125;) Limit与Skip方法Limit如果你需要在mongodb中读取指定数量的数据记录，可以使用mongodb的Limit方法，limit()方法接受一个数字参数，该参数指定从mongodb中读取的记录条数。 1db.age.find().limit(数量) Skip我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。 12db.age.find().limit(数量).skip(数量)//skip()方法默认值为0 所以我们在实现分页的时候就可以用limit来限制每页多少条数据(一般固定一个值)，用skip来决定显示第几页(一个有规律变动的值) 排序在mongodb中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用1和-1来指定排序的方式，其中1为升序排列，而-1是用于降序排列。 1 升序排列-1 降序排列 1db.集合名.find().sort(&#123;键值(属性值):1&#125;) 把age集合表重新根据_id主键进行降序排列 123db.age.find().sort(&#123; \"_id\": -1&#125;) Node.js连接安装mongodb的模块 1npm install mongodb 1.连接数据库123456var MongoClient = require('mongodb').MongoClient;//结尾是选择数据库名var DB_CONN_STR = 'mongodb://localhost:27017/wscats';MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\");&#125;); 2.查询数据注意查询回来的结果需要toArray来遍历处理 1234567891011121314var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/wscats';MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); //选中age集合，并用find方法把结果集拿回来进行处理 db.collection(\"age\").find(&#123;title: \"cba\"&#125;).toArray(function(err, result) &#123; if (err) &#123; console.log('Error:' + err); return; &#125; console.log(result); &#125;);&#125;); 经过测试，读取大于100条的时候会出现报错官网解释，可以尝试用forEach代替 1234db.collection('pokemon').find(&#123;&#125;) .forEach(function(item)&#123; console.log(item) &#125;) 查询ID查询自动生成的ObjectId 1234567var ObjectId = require('mongodb').ObjectId;let _id = ObjectId(\"5bcae50ed1f2c2f5e4e1a76a\");db.collection('xxx').find(&#123; \"_id\": _id&#125;).forEach(function (item) &#123; console.log(item)&#125;) 3.插入数据insert函数第一个参数是需要插入的值(可以一个也可以多个)，第二个参数是接受一个回调函数，当值插入成功后回返回插入值得一些关键信息，比如_id 1234567891011121314151617181920var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/wscats';MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\");const db = client.db(\"demo\"); db.collection(\"age\").insert([ &#123; title: \"插入的值A\" &#125;, &#123; title: \"插入的值B\" &#125; ], function(err, result) &#123; if (err) &#123; console.log('Error:' + err); return; &#125; console.log(result) &#125;)&#125;); 4.更新数据注意如果不加$set就是完全替换原来的那份(没有设置的属性值将会丢失)，加上$set则只是更新对应的属性值，其余不做改变 1234567891011121314151617181920var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/wscats';MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); db.collection(\"age\").update(&#123; \"_id\": 1 &#125;, &#123; $set: &#123; title: \"你好，世界\", skill: \"js\" &#125; &#125;, function(err, result) &#123; if (err) &#123; console.log('Error:' + err); return; &#125; //console.log(result); &#125;);&#125;); 5.删除数据1234567891011121314151617var MongoClient = require('mongodb').MongoClient;var DB_CONN_STR = 'mongodb://localhost:27017/wscats';MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); db.collection(\"age\").remove(&#123; \"_id\": 1 &#125;, function(err, result) &#123; if (err) &#123; console.log('Error:' + err); return; &#125; //console.log(result); //关闭数据库 db.close(); &#125;);&#125;); 6.关闭数据库1db.close(); 封装自定义模块新建mongo.js写入以下代码，封装自定义模块，方便其他路由复用，注意assert是node自带的断言模块，用于测试代码 参考 官网API文档 Node.js的断言模块assert进行单元测试 12345678910111213141516const MongoClient = require('mongodb').MongoClient;const assert = require('assert');const url = 'mongodb://localhost:27017';const dbName = 'shop';function query(callback) &#123; MongoClient.connect(url, function(err, client) &#123; assert.equal(null, err); console.log(\"Connected successfully to server\"); const db = client.db(dbName); callback(db); client.close(); &#125;);&#125;module.exports = &#123; query&#125; 在路由文件中引入和使用 123456789var mongo = require('./mongo.js')router.post('/addproduct', function(req, res, next) &#123; mongo.query(function(db) &#123; db.collection(\"product\").insertMany([req.body], function(err, result) &#123; console.log(\"Inserted 1 document into the collection\"); res.send('respond with a resource'); &#125;); &#125;)&#125;); mongoose 可视化 Robo 3T Studio3t Socketsocket.io12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;socket.io&lt;/title&gt; &lt;script src=\"socket.io.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;gp6 交流区&lt;/h1&gt; &lt;div id=\"content\" name=\"name\" style=\"overflow-y: scroll; width: 400px; height: 300px; border: solid 1px #000\"&gt;&lt;/div&gt; &lt;br /&gt; &lt;div&gt; &lt;input type=\"text\" id=\"msg\" style=\"width: 200px;\"&gt; &lt;/div&gt; &lt;button id=\"submit\"&gt;提交&lt;/button&gt; &lt;script&gt; var socket = io.connect('http://10.9.164.98:8081'); const content = document.getElementById('content') document.querySelector('#submit') .addEventListener('click', function () &#123; var msg2 = msg.value socket.emit('receive', msg2) msg.value = '' content.innerHTML += msg2 + '&lt;br/&gt;' &#125;, false) socket.on('message', function(msg)&#123; content.innerHTML += msg + '&lt;br/&gt;' &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; server.js 12345678910111213141516171819202122var express = require('express');var app = express();var server = require('http').Server(app);var io = require('socket.io')(server);app.use(express.static(__dirname + '/client'))io.on('connection', function (socket) &#123; setInterval(function () &#123; socket.emit('list', 'abc') &#125;, 1000) socket.broadcast.emit('list', 'test'); socket.on('backend', (msg) =&gt; &#123; console.log(msg); &#125;) socket.on('receive', (msg) =&gt; &#123; socket.broadcast.emit('message', msg); &#125;)&#125;);server.listen(8081, '10.9.164.98'); net模块serverCode 12345678910111213141516171819202122232425262728293031323334const net = require('net')const server = new net.createServer()let clients = &#123;&#125;let clientName = 0server.on('connection', (client) =&gt; &#123; client.name = ++clientName clients[client.name] = client client.on('data', (msg) =&gt; &#123; // console.log('客户端传来：' + msg); broadcast(client, msg.toString()) &#125;) client.on('error', (e) =&gt; &#123; console.log('client error' + e); client.end() &#125;) client.on('close', (data) =&gt; &#123; delete clients[client.name] console.log(client.name + ' 下线了'); &#125;)&#125;)function broadcast(client, msg) &#123; for (var key in clients) &#123; clients[key].write(client.name + ' 说：' + msg) &#125;&#125;server.listen(9000) clientCode 123456789101112131415161718192021222324252627282930313233343536373839404142var net = require('net')const readline = require('readline')var port = 9000var host = '127.0.0.1'var socket = new net.Socket()socket.setEncoding = 'UTF-8'socket.connect(port, host, () =&gt; &#123; socket.write('hello.')&#125;)socket.on('data', (msg) =&gt; &#123; console.log(msg.toString()) say()&#125;)socket.on('error', function (err) &#123; console.log('error' + err);&#125;)socket.on('close', function () &#123; console.log('connection closeed');&#125;)const r1 = readline.createInterface(&#123; input: process.stdin, output: process.stdout&#125;)function say() &#123; r1.question('请输入：', (inputMsg) =&gt; &#123; if (inputMsg != 'bye') &#123; socket.write(inputMsg + '\\n') &#125; else &#123; socket.destroy() r1.close() &#125; &#125;)&#125; websocket12345678910111213141516171819const ws = new WebSocket('ws://localhost:8080/')ws.onopen = () =&gt; &#123; ws.send('大家好')&#125;ws.onmessage = (msg) =&gt; &#123; const content = document.getElementById('content') content.innerHTML += msg.data + '&lt;br/&gt;'&#125;ws.onerror = (err) =&gt; &#123; console.log(err);&#125;ws.onclose = () =&gt; &#123; console.log('closed~');&#125;ws.send(msg2) server.js 12345678910111213141516171819202122232425const WebSocket = require('ws')const ws = new WebSocket.Server(&#123; port: 8080 &#125;)let clients = &#123;&#125;let clientName = 0ws.on('connection', (client) =&gt; &#123; client.name = ++clientName clients[client.name] = client client.on('message', (msg) =&gt; &#123; broadcast(client, msg) &#125;) client.on('close', () =&gt; &#123; delete clients[client.name] console.log(client.name + ' 离开了~') &#125;)&#125;)function broadcast(client, msg) &#123; for (var key in clients) &#123; clients[key].send(client.name + ' 说：' + msg) &#125;&#125; 项目实战api接口 RestfulApi 规范 接口文档的生成(apidoc) 接口请求方式区别 跨域解决 cors jsonp proxy 身份验证JWT产生token 12var jwt &#x3D; require(&#39;jsonwebtoken&#39;);var token &#x3D; jwt.sign(&#123; foo: &#39;bar&#39; &#125;, &#39;shhhhh&#39;); 验证token 1234&#x2F;&#x2F; verify a token symmetricjwt.verify(token, &#39;shhhhh&#39;, function(err, decoded) &#123; console.log(decoded.foo) &#x2F;&#x2F; bar&#125;); Cookie+Session1234567891011npm install express-session -d --saveapp.use(session(&#123; secret: &quot;weird sheep&quot;, resave: false, saveUninitialized: true, cookie: &#123;user:&quot;default&quot;,maxAge: 14*24*60*60*1000&#125;&#125;));session存值req.session.user &#x3D; user;req.session.isLogin &#x3D; true; ​ 图片上传 安装multer模块 1npm install multer 引用模块它是依赖于express的一个模块 1234//引用express并配置var express = require(\"express\");var app = express();app.listen(3000); 123456var multer = require('multer');/*var upload = multer(&#123; //如果用这种方法上传，要手动添加文明名后缀 //如果用下面配置的代码，则可以省略这一句 dest: 'uploads/'&#125;)*/ 配置设置保存文件的地方，并根据上传的文件名对应文件添加后缀可以通过filename属性定制文件保存的格式 属性值 用途 destination 设置资源的保存路径。注意，如果没有这个配置项，默认会保存在/tmp/uploads下。此外，路径需要自己创建 filename 设置资源保存在本地的文件名 12345678910111213141516var storage = multer.diskStorage(&#123; //设置上传后文件路径，uploads文件夹会自动创建。 destination: function(req, file, cb) &#123; cb(null, './uploads') &#125;, //给上传文件重命名，获取添加后缀名 filename: function(req, file, cb) &#123; var fileFormat = (file.originalname).split(\".\"); //给图片加上时间戳格式防止重名名 //比如把 abc.jpg图片切割为数组[abc,jpg],然后用数组长度-1来获取后缀名 cb(null, file.fieldname + '-' + Date.now() + \".\" + fileFormat[fileFormat.length - 1]); &#125;&#125;);var upload = multer(&#123; storage: storage&#125;); 接受文件upload.single(&#39;xxx&#39;)，xxx与表单中的name属性的值对应这里虽然用到post请求，但实际上不需要bodyParser模块处理 1234567891011app.post('/upload-single', upload.single('logo'), function(req, res, next) &#123; console.log(req.file) console.log('文件类型：%s', req.file.mimetype); console.log('原始文件名：%s', req.file.originalname); console.log((req.file.originalname).split(\".\")) console.log('文件大小：%s', req.file.size); console.log('文件保存路径：%s', req.file.path); res.send(&#123; ret_code: '0' &#125;);&#125;); 多图上传多图上传只要更改一下地方，前端往file输入框加多一个multiple=&quot;multiple&quot;属性值，此时就可以在选图的时候多选了，当然也可以并列多个file输入框(不推荐多个上传图片输入框)，这样体验会不好 1&lt;input type=\"file\" name=\"logo\" multiple=\"multiple\" /&gt; 后端也需要相应的改变 123app.post('/upload-single', upload.single('logo'), function(req, res, next) &#123;//upload.single('logo')变为upload.array('logo', 2)，数字代表可以接受多少张图片app.post('/upload-single', upload.array('logo', 2), function(req, res, next) &#123; 如果不想有图片数量上传限制，我们可以用upload.any()方法 123456app.post('/upload-single', upload.any(), function(req, res, next) &#123; res.append(\"Access-Control-Allow-Origin\",\"*\"); res.send(&#123; wscats_code: '0' &#125;);&#125;); 前端部分 formData表单提交 12345&lt;form action=\"http://localhost:3000/upload-single\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;h2&gt;单图上传&lt;/h2&gt; &lt;input type=\"file\" name=\"logo\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; formData表单+ajax提交 12345&lt;form id=\"uploadForm\"&gt; &lt;p&gt;指定文件名： &lt;input type=\"text\" name=\"filename\" value=\"\" /&gt;&lt;/p&gt; &lt;p&gt;上传文件： &lt;input type=\"file\" name=\"logo\" /&gt;&lt;/ p&gt; &lt;input type=\"button\" value=\"上传\" onclick=\"doUpload()\" /&gt;&lt;/form&gt; FormData对象，是可以使用一系列的键值对来模拟一个完整的表单，然后使用XMLHttpRequest发送这个”表单” 注意点 processData设置为false。因为data值是FormData对象，不需要对数据做处理。 &lt;form&gt;标签添加enctype=&quot;multipart/form-data&quot;属性。 cache设置为false，上传文件不需要缓存。 contentType设置为false。因为是由&lt;form&gt;表单构造的FormData对象，且已经声明了属性enctype=&quot;multipart/form-data&quot;，所以这里设置为false 上传后，服务器端代码需要使用从查询参数名为logo获取文件输入流对象，因为&lt;input&gt;中声明的是name=&quot;logo&quot; 12345678910111213function doUpload() &#123; $.ajax(&#123; url: 'http://localhost:3000/upload-single', type: 'POST', cache: false, //不必须 data: new FormData($('#uploadForm')[0]), processData: false,//必须 contentType: false,//必须 success: function(data) &#123; console.log(data) &#125; &#125;)&#125; 参考文档Github MyDemoGithub MulterMDN FormData对象的使用","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://wjhzs.github.io/categories/Node-js/"}],"tags":[{"name":"node.js介绍","slug":"node-js介绍","permalink":"https://wjhzs.github.io/tags/node-js%E4%BB%8B%E7%BB%8D/"}],"author":"魏经海"},{"title":"博客写作","slug":"博客写作","date":"2020-07-21T08:26:30.000Z","updated":"2020-07-22T00:39:23.076Z","comments":true,"path":"2020/07/21/博客写作/","link":"","permalink":"https://wjhzs.github.io/2020/07/21/%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/","excerpt":"Hexo博客写作的基本操作在阅读这篇文章之前，你也可以浏览Hexo官方文档，来熟悉写作的基础知识。Hexo写作文档","text":"Hexo博客写作的基本操作在阅读这篇文章之前，你也可以浏览Hexo官方文档，来熟悉写作的基础知识。Hexo写作文档 在熟悉写作之前，先要熟悉hexo文件目录中存放文章和页面的路径位置。&emsp; &emsp; Hexo 有三种默认布局：post、page 和 draft。在创建者三种不同类型的文件时，它们将会被保存到不同的路径。 &emsp; &emsp; 首先我们执行 hexo new post 文章标题 命令创建一篇新的文章，都将储存到 source/_posts 文件夹 执行 hexo new page 页面名称命令 创建新的页面，都会在 source/ 文件夹下自动创建一个与页面名称相同的文件夹 &emsp; &emsp; 执行hexo new draft 文章名 命令创建一个草稿文章，草稿的意思不用多说，所以，当你编辑并保存之后，通过hexo s 启动服务器之后，刷新页面并不会显示你编辑的这篇草稿；通过hexo s --``draft 启动服务器，再刷新页面就会显示你这篇草稿文章了 ，但这仅仅是显示，只有你自己能看见，别人是无法看见的，此时，执行 hexo publish 草稿文章名称 命令就可以将草稿文章发布出去了。 Front-matter&emsp; &emsp; 无论是新建文章或生成新的页面，都会有一个md文件，文件最上方以 --- 分隔的区域，就是Front-matter；主要内容就是文章的相关配置信息；标题，作者等； 举例来说： 1234---title: Hello Worlddate: 2013&#x2F;7&#x2F;13 20:46:25--- &emsp; &emsp; 这是每次新建文章之后自动生成的两个配置，是不是有点少，其他想加上去的配置还得自己动手再加上去，如果想 hexo new ... 之后其他配置就自动加上去呢，你需要去hexo主目录下找到scaffolds文件夹下找到一个post.md文件添加配置就ok了。 &emsp; &emsp; 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） &emsp; &emsp; 以上就是文章和页面书写的基础操作了，剩下的页面或文章内容就可以根据你的需要来写了，你可以分享自己的学习心得，学习资源等，页面内容的丰富性，以及美观性就需要你自己慢慢学习与积累了，写博客就像写代码，练习的多了，写的多了，自然就熟练了，思路也会清晰了。 支持的格式&emsp; &emsp; Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。 &emsp; &emsp; 例如，Hexo 默认安装了 hexo-renderer-marked 和 hexo-renderer-ejs，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 hexo-renderer-pug，你甚至可以用 Pug 模板语言书写文章。只需要将文章的扩展名从 md 改成 ejs，Hexo 就会使用 hexo-renderer-ejs 渲染这个文件，其他格式同理。 &emsp; &emsp; Markdown教程可参照： 菜鸟教程-markdown教程","categories":[],"tags":[],"author":"魏经海"},{"title":"Vue的安装","slug":"Vue的安装","date":"2020-07-20T12:32:44.000Z","updated":"2020-07-20T23:56:04.208Z","comments":true,"path":"2020/07/20/Vue的安装/","link":"","permalink":"https://wjhzs.github.io/2020/07/20/Vue%E7%9A%84%E5%AE%89%E8%A3%85/","excerpt":"Vue介绍Vue：一个构建用户界面的渐进式JavaScript框架","text":"Vue介绍Vue：一个构建用户界面的渐进式JavaScript框架 优点： 易用，已经学会了HTML,CSS,JavaScript,可以立刻阅读文档开始构建应用。 灵活，不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩。 运行效率高，采用了虚拟dom，减少了真是dom的操作。 开发效率高，采用了组件化开发，将开发者的精力从dom操作解放出来，转移到数据操作上。 Vue安装 直接在Vue官网下载Vue.js通过script标签引入 使用CDN方法：CDN: https://cdn.staticfile.org/vue/2.2.2/vue.min.js 使用npm安装先切换到淘宝下载地址：npm install -g cnpm –registry=https://registry.npm.taobao.org，然后通过：npm install vue 下载到相应的文件夹内 Vue的更新日志 每个版本的更新日志见 GitHub。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://wjhzs.github.io/categories/Vue/"}],"tags":[{"name":"Vue安装方法","slug":"Vue安装方法","permalink":"https://wjhzs.github.io/tags/Vue%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/"}]},{"title":"Java面向对象概述","slug":"Java面向对象概述","date":"2020-07-20T06:05:03.000Z","updated":"2020-07-22T00:37:57.534Z","comments":true,"path":"2020/07/20/Java面向对象概述/","link":"","permalink":"https://wjhzs.github.io/2020/07/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/","excerpt":"一.面向对象思想​ 面向对象相对于于面向过程而言，都是一种思想","text":"一.面向对象思想​ 面向对象相对于于面向过程而言，都是一种思想 ​ 面向过程：强调是一个功能的步骤 ​ 面向对象：强调的是一个对象，然后由这个对象去完成相应的功能。 ​ 面向对象 特点：封装，继承，多态 ​ 好处： 1.是一种符合人们思考习惯的思想 2.可以将复杂的东西简单化 3.将程序员从执行者转为命令者 二.类与对象​ 生活中描述对象一般都是从静态属性和动态属性来描述 ​ 例：人 静态属性：名字，年龄，身高等~ 动态属性：人可以工作，打电话，说话等~ ​ 在Java语言中描述事物是通过类来完成的 静态属性–&gt;用成员变量来描述 动态属性–&gt;用成员函数（方法）来描述 ​ 对象是一个类的具体实例，Java中通过 new关键字来实现 通过一个例子来描述如下： 123456789101112131415161718class Person&#123; String name;//成员变量。 （在类与成员函数之间） int age;//成员变量 public void talk()&#123;//成员函数 &#125;&#125;class Demo&#123; public static void main(String[]args)&#123; Person p=new Person(); //通过new关键字来创建对象 p.talk();//调用函数 （格式：对象名.函数） &#125;&#125; 本网站相关的Java知识，都是自己学习Java时的个人总结，有些不对的地方请指正","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wjhzs.github.io/tags/Java/"}]}],"categories":[{"name":"git","slug":"git","permalink":"https://wjhzs.github.io/categories/git/"},{"name":"Vue","slug":"Vue","permalink":"https://wjhzs.github.io/categories/Vue/"},{"name":"Mongodb","slug":"Mongodb","permalink":"https://wjhzs.github.io/categories/Mongodb/"},{"name":"MySQL","slug":"MySQL","permalink":"https://wjhzs.github.io/categories/MySQL/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://wjhzs.github.io/categories/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://wjhzs.github.io/categories/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://wjhzs.github.io/categories/HTML/"},{"name":"Node.js","slug":"Node-js","permalink":"https://wjhzs.github.io/categories/Node-js/"}],"tags":[{"name":"git分支","slug":"git分支","permalink":"https://wjhzs.github.io/tags/git%E5%88%86%E6%94%AF/"},{"name":"Vue全局状态管理模式","slug":"Vue全局状态管理模式","permalink":"https://wjhzs.github.io/tags/Vue%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"name":"mongodb介绍","slug":"mongodb介绍","permalink":"https://wjhzs.github.io/tags/mongodb%E4%BB%8B%E7%BB%8D/"},{"name":"MySQL介绍","slug":"MySQL介绍","permalink":"https://wjhzs.github.io/tags/MySQL%E4%BB%8B%E7%BB%8D/"},{"name":"JavaScript介绍","slug":"JavaScript介绍","permalink":"https://wjhzs.github.io/tags/JavaScript%E4%BB%8B%E7%BB%8D/"},{"name":"CSS介绍","slug":"CSS介绍","permalink":"https://wjhzs.github.io/tags/CSS%E4%BB%8B%E7%BB%8D/"},{"name":"HTML介绍","slug":"HTML介绍","permalink":"https://wjhzs.github.io/tags/HTML%E4%BB%8B%E7%BB%8D/"},{"name":"git介绍","slug":"git介绍","permalink":"https://wjhzs.github.io/tags/git%E4%BB%8B%E7%BB%8D/"},{"name":"node.js介绍","slug":"node-js介绍","permalink":"https://wjhzs.github.io/tags/node-js%E4%BB%8B%E7%BB%8D/"},{"name":"Vue安装方法","slug":"Vue安装方法","permalink":"https://wjhzs.github.io/tags/Vue%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://wjhzs.github.io/tags/Java/"}]}